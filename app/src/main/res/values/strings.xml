<resources>
    <string name="app_name">ComingBack</string>

    <!-- Basic Logic -->
    <string name="not_gate">The logic of the NOT gate (otherwise known as an inverter) is that it simply reverses whatever signal it receives. In other words, if it receives an \"on\" signal, it outputs an \"off\" signal; and vice versa, it outputs \"on\" when it receives an \"off\" signal.</string>
    <string name="and_gate">The AND gate is simply the opposite of the NAND gate. In other words, it outputs an "on" signal only when both of its inputs receive an "on" signal. This can be achieved by simply placing an inverter after a NAND gate.</string>
    <string name="nor_gate">The logic of the NOR gate is simply the opposite of the OR gate. In other words, it outputs an "on" signal only when neither of its inputs receives an "on" signal. This can be achieved by inverting both input and output of a NAND gate.</string>
    <string name="or_gate">Much like the NAND/AND relation, NOR/OR are simply opposites of each other. The OR gate will output an "on" signal as long as any of its inputs are on. This can be achieved by simply removing the inverter after the NAND in the NOR gate schematic.</string>
    <string name="always_on_gate">As its name suggests, the logic of the Always On always outputs an "on" signal. This can be achieved by using a NOT gate tied to one of the inputs of an OR gate.</string>
    <string name="second_tick_gate">Again, as its name suggests, the logic of the Second Tick only outputs an "on" signal during the second tick of tests. In other words, when its first input receives an "on" signal and its second input receives an "off" signal. This can be achieved by using a NOT gate tied to the second input of an AND gate.</string>
    <string name="xor_gate">Slightly different from the OR gate, the XOR gate still outputs "on" when either of its inputs receives an "on" signal; however, it outputs an "off" when both inputs receive an "on" signal. In other words, OR > AND &lt; NAND.</string>

    <!-- ARITHMETIC -->
    <string name="double_trouble">The logic for Double Trouble is that it simply requires you to output an "on" signal when at least two of the inputs are receiving an "on" signal.</string>
    <string name="odd_number_of_signals">Much like the previous level, this one requires an "on" signal output when the inputs receive a particular number of "on" signals. The difference here is that we only output an "on" signal when an odd number of inputs receive an "on" signal. In other words, when either 1 or 3 inputs are "on" we output an "on" signal.</string>
    <string name="counting_signals">As the name suggests, this level requires us to count the input signals. The output component has 3 nodes on it and operates much like a Byte Maker; the first (top) node has a value of 1, the second (middle) has a value of 2, and the third (bottom) has a value of 4.</string>
    <string name="half_adder">As the name suggests, this level performs addition using the inputs. Everything is computed in binary; meaning that "1+1=2" is written as "01+01=10" with one output called "SUM" being the main value (for if the value is 0 or 1) and the other output called "CAR" being the carry (for if the value is 2).</string>
    <string name="double_the_number">As the name suggests, in this level you simply have to double the value of whatever the input is. With the provided Byte Splitter/Byte Maker components, this is extremely easy; as you can simply pass each bit to its doubled value bit (i.e. 1 to 2, 2 to 4, 4 to 8, and so on).</string>
    <string name="full_adder">Much like Half Adder, this level performs addition using the inputs. The difference is that it uses a total of three inputs/bits; so, now we can have a value of three with the &quot;SUM&quot; output still being for values of 0 (off) or 1 (on) and the &quot;CAR&quot; output still being the carry for when we have a value of 2 (when it\'s on). Due to the composition of the components, both &quot;SUM&quot; and &quot;CAR&quot; can be on at the same time, making the total value of three.</string>
    <string name="byte_or">Much like the name suggests, this level simply ORs each pair of corresponding bits within two byte values.</string>
    <string name="byte_not">Much like the name suggests, this level simply NOTs each individual bit within a byte value.</string>
    <string name="adding_bytes">Much like the name suggests, this level adds together two byte values using Full Adder components for each pair of bits.</string>
    <string name="signed_negator">In order to understand the logic of this level, you need to understand 2\'s Complement. Basically, 2\'s Complement simply inverts a value, and then adds one to it in order to get the negative of the original value. So, 00100101 (a value of 15) is first negated, making it 11011010, and then has one added to it, making it 11011011 (the binary equivalent of -15).</string>
    <string name="one_bit_decoder">Here, the problem is to have one output turned on when the input is off, and have the other output turned on when the input is on. The solution is to incorporate a NOT gate on one output and have a straight feed to the other.</string>
    <string name="three_bit_decoder">Here, we have a similar problem to the previous level; however, instead of choosing between 2 outputs using a single input, we have to choose between eight outputs using three inputs.</string>
    <string name="logic_engine">Here is where we put everything together. We incorporate decoders and byte-gates to create a logic engine capable of doing OR, NOR, AND, and NAND operations on two different byte arguments.</string>

    <!-- MEMORY -->
    <string name="circular_dependency">This is a tutorial level that simply requires you to create a circuit whose input depends on it\'s output. There are two checks; one where it checks if there\'s a circular dependency, and another where it checks if you\'ve used at least two components.</string>
    <string name="delayed_lines">This level introduces a component that delays the output of its input. The solution is to simply place two of them in a row.</string>
    <string name="odd_ticks">This level is somewhat bizarre. The requirement is to have a circuit that outputs an "on" signal only during every other tick (starting with the second tick). The solution is to have a Delay Line component feed itself through a NOT gate; and have the output take the feed from the Delay Line; meanwhile, ignoring the Input component entirely. Fun Fact: The is basically the implementation of a "clock" circuit; the more delays you have in the circuit, the more ticks between pulses.</string>
    <string name="bit_switch">In this level, the goal is to create an XOR circuit using only two NOT gates and two SWITCH components. The SWITCH component is special because of its grey output pin, which signifies that it is not outputting anything as long as the switch itself is not enabled; meaning that multiple switch outputs can be connected to the same wire/component as long as only one switch is enabled at any given time.</string>
    <string name="bit_inverter">This level is a bit of a riddle; you are required to output the opposite of the "Value" bit whenever the "Invert" bit is active, and simply output the "Value" otherwise. With close enough attention though, it becomes fairly obvious that the desired result is the exact same output as an XOR gate.</string>
    <string name="input_selector">This level is very similar to the Bit Switch level; however, instead of switching between two bits, we\'re switching between two bytes.</string>
    <string name="the_bus">In this level, we have two byte inputs, two byte outputs, and two bit inputs. The values of the two bit inputs determine which byte input we want to pass to which byte output. The concept of a bus is simply a wire that can hold a value from multiple separate sources; however, it still can only hold one value at a time. By using SWITCH components and NOT gates, we can create a controllable bus circuit.</string>
    <string name="saving_bytes">Using the new memory component; our goal in this level is to save an entire byte of data, and output said byte on command.</string>
    <string name="little_box">This level requires us to construct an operating set of four bytes of memory (essentially, four bytes of RAM) within a limited amount of space. Although somewhat difficult, it is entirely possible. NOTE: My solution, though it works, is not particularly pretty. If anyone has a more aesthetically pleasing solution; I\'m more than happy to verify and use it within this guide.</string>
    <string name="counter">Here, as the level name suggests, we are required to construct a counter. Our counter must be able to not only count, but also overwrite the count value on command.</string>

    <!-- CPU Architecture-->
    <string name="arithmetic_engine">Here, we are required to modify our Logic Engine and incorporate the ability to add and subtract two inputs. The solution is relatively easy; we simply have to add a couple of byte adders (one of them with a byte negation before its input) and add some new switches to toggle those results.</string>
</resources>